## 第 5 章    强制复制消除或传递未实质化对象

本章的主题可以从两个角度来看：
+ 技术上，C++17 引入了在特定条件下*强制复制消除*（mandatory copy elision）的新规则：之前的针对按值传递或返回临时对象时对复制的消除，现在成为强制的。
+ 这样做的效果是我们传递*未实质化对象*（unmaterialized object）的值进行初始化。

我将从技术层面介绍这一特性，随后是它的效果和*实质化*（materialization）的术语。

### 5.1    临时量的强制复制消除的动机

从首个标准开始，C++ 就允许省略（elision）某些复制操作，即使这可能影响程序的行为（例如，跳过复制构造函数中的打印语句）。一种这样的情况是使用临时对象初始化新对象。特别是当临时量按值传递给函数或从函数返回时，就会发生这种情况。例如：

```c++
class MyClass
{
  ...
};

void foo(MyClass param) {   // 用传递的实参初始化 param
  ...
}

MyClass bar() {
  return MyClass{};         // 返回临时量
}

int main()
{
  foo(MyClass{});       // 传递临时量以初始化 param
  MyClass x = bar();    // 使用返回的临时量初始化 x
  foo(bar());           // 使用返回的临时量初始化 param
}
```

然而，由于这些优化不是强制的，因此必须通过隐式或显式提供复制或移动构造函数，以允许复制对象。也就是说，尽管复制/移动构造函数通常不被调用，它也必须存在。当没有定义复制/移动构造函数时，这样的代码不能编译。

因此，若 `MyClass` 的定义如下，上面的代码就不能编译：

```c++
class MyClass
{
 public:
  ...
  // 没有定义复制/移动构造函数
  MyClass(const MyClass&) = delete;
  MyClass(MyClass&&) = delete;
  ...
};
```

没有复制构造函数就够了，因为移动构造函数仅在没有用户声明的复制构造函数（以及赋值运算符和析构函数）时才隐式可用。

从 C++17 起，从临时量初始化对象的复制消除是强制的。实际上，我们稍后将会看到，我们只需将初始化值作为实参或返回值传递，然后该值用于*实质化*新对象。

这意味着即使类 `MyClass` 的定义完全禁止复制，上面的示例仍然能编译。

然而，注意所有其他可选的复制消除仍然是可选的，并且要求可调用的复制或移动构造函数。例如：

```c++
MyClass foo()
{
  MyClass obj;
  ...
  return obj;   // 仍然要求复制/移动支持
}
```

此处，`foo()` 包含变量 `obj`，它拥有名字（使用时是左值，见 5.3.1 节）。因此，会使用***具名****返回值优化*（named return value optimization，NRVO），这仍然要求复制/移动支持。即使 `obj` 是形参，也是这种情况：

```c++
MyClass bar(MyClass obj)    // 针对传递的临时量的复制消除
{
  ...
  return obj;   // 仍然要求复制/移动支持
}
```

传递临时量（使用时为纯右值，见 5.3.1 节）到函数不再是复制/移动，但返回该形参要求复制/移动支持，因为被返回的对象有名字。

作为这一更改的一部分，对值类别的术语进行了一些修改和澄清（见 5.3 节）。