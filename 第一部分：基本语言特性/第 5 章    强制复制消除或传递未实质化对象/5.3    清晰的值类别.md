### 5.3    清晰的值类别

在初始化新对象时要求对临时量执行复制消除的提案更改产生了一项副作用，它对*值类别*（value category）进行了一些调整。

#### 5.3.1    值类别

C++ 程序中的每个表达式都有值类别。特别地，值类别描述了可以用表达式做什么。

##### 值类别的历史

历史上（来自 C），我们只有*左值*（lvalue）和*右值*（rvalue），根据赋值区分：

```c++
x = 42;
```

其中用作表达式的 `x` 是*左值*（lvalue），因为它能位于赋值的左侧，而作为表达式的 `42` 是*右值*（rvalue），因为它只能用于右侧。但是，在 ANSI-C 中事情已经变得更复杂了，因为声明为 `const int` 的 `x` 不能位于赋值的左侧，但它仍然是（不可修改的）左值。

随后，C++11 引入了可移动的对象，从语义的角度来看，它只是用于赋值右侧的对象，但可以修改，因为赋值运算符可以窃取其值。因此，引入了类别*亡值*（xvalue），而之前的类别*右值*（rvalue）被重命名为*纯右值*（prvalue）。

##### C++11 起的值类别

C++11 起，值类别由图 5.1 描述：有核心类别*左值*（lvalue），*纯右值*（prvalue，pure rvalue）和*亡值*（xvalue，eXpiring value）。复合类别有：*泛左值*（glvalue，generalized lvalue，这是*左值*和*亡值*的结合）和*右值*（rvalue，是*亡值*和*纯右值*的结合）。

***左值***（lvalue）的例子有：
+ 仅仅是变量、函数或成员的名字的表达式
+ 字符串字面值表达式
+ 内建一元 `*` 运算符的结果（即解引用原始指针产生的结果）
+ 返回左值引用的函数的结果（*type*&）

***纯右值***（prvalue）的例子有：
+ 由非字符串字面值（或用户定义字面值，由与之关联的字面值运算符的返回类型决定值类别）组成的表达式
+ 内建一元 `&` 运算符的结果（即获取表达式的地址产生的结果）
+ 内建算术运算符的结果
+ 按值返回的函数的结果
+ lambda 表达式

***亡值***（xvalue）的例子有：
+ 返回右值引用的函数的结果（*type*&&，特别是 `std::move()` 返回的结果）
+ 到对象类型的右值引用的转换

大致而言：
+ 所有用作表达式的名字都是*左值*。
+ 所有用作表达式的字符串字面值都是*左值*。
+ 所有其它字面值（`4.2`，`true` 或 `nullptr`）都是*纯右值*。
+ 所有临时量（特别是按值返回的对象）是*纯右值*。
+ `std::move()` 的结果是*亡值*。

例如：

```c++
class X {
};

X v;
const X c;

void f(const X&);   // 接受任意值类别的表达式
void f(X&&);        // 只接受纯右值和亡值，但是更优的匹配

f(v);               // 为第一个 f() 传递可修改的左值
f(c);               // 为第一个 f() 传递不可修改的左值
f(X());             // 为第二个 f() 传递纯右值
f(std::move(v));    // 为第二个 f() 传递亡值
```

值得强调的是，严格来说，泛左值、纯右值和亡值是描述表达式的术语，而*不是*值的术语（这意味着这些术语用词不当）。例如，变量本身不是左值；只有表示该变量的表达式才是左值：

```c++
int x = 3;  // 此处 x 是变量，不是左值
int y = x;  // 此处 x 是左值
```

在第一条语句中，`3` 是纯右值，用于初始化变量（不是左值）`x`。在第二条语句中，`x` 是左值（其求值结果指定了一个包含值 `3` 的对象）。左值 `x` 被转换为纯右值，用来初始化变量 `y`。

#### 5.3.2    C++17 起的值类别

C++17 阐明了值类别的语义含义，如图 5.2 描述。

现在解释值类别的关键方法是，一般来说，我们有两种类型的表达式：

+ **泛左值**：表示对象或函数的*位置*的表达式
+ **纯右值**：用于*初始化*的表达式

随后**亡值**被认为是一种特殊的位置，表示资源可以被重用的对象（通常是因为该对象接近其生命周期的末尾）。

然后 C++17 引入了一个新的术语，叫做（临时量的）*实质化*（materialization），实质化后的纯右值变成了临时对象。因此，*临时量实质化转换*（temporary materialization conversion）是一种纯右值到亡值转换。

任何时刻纯右值有效地出现在期望泛左值（左值或亡值）的位置时，都会创建一个临时对象，并从该纯右值初始化（记住纯右值主要是“初始化值”），并且该纯右值被一个表示该临时量的*亡值*所替换。所以在上面的例子中，严格来说我们有：

```c++
void f(const X& p);     // 接受任意值类别的表达式，
                        // 但期望泛左值

f(X());                 // 传递纯右值，实质化为亡值
```

由于这个例子中 `f()` 具有引用形参，因此它期待泛左值实参。然而，表达式 `X()` 是纯右值。因此，“临时量实质化”规则开始生效，并且表达式 `X()` 被“转换”为一个亡值，该亡值指代一个临时对象，由默认构造函数初始化。

注意实质化不表示我们创建了一个新的/不同的对象。左值引用 `p` 仍然*绑定*（bind）到亡值和纯右值，尽管后者现在始终涉及到亡值的转换。

有了这一修改（纯右值不再是对象，而是可以用于初始化对象的表达式），要求的复制消除非常有意义，因为纯右值不再需要是可移动的才能使用赋值语法初始化变量。我们只需要传递一个初始值，它迟早会被*实质化*以初始化一个对象。[^1]

[^1]:感谢 Richard Smith 和 Graham Haynes 指出这一点。