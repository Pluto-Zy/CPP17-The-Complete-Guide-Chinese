### 8.3    宽松的从整数值的枚举初始化

从 C++17 起，对于有确定底层类型的枚举，你可以将该类型的整数值用于直接列表初始化。这适用于带有指定类型的无作用域枚举，以及所有的有作用域枚举，因为它们永远具有默认底层类型：

```c++
// 带有底层类型的无作用域枚举：
enum MyInt : char { };
MyInt i1{42};           // C++17 起正确（C++17 前错误）
MyInt i2 = 42;          // 仍然错误
MyInt i3(42);           // 仍然错误
MyInt i4 = {42};        // 仍然错误

// 带有默认底层类型的有作用域枚举：
enum class Weekday { mon, tue, wed, thu, fri, sat, sun };
Weekday s1{0};          // C++17 起正确（C++17 前错误）
Weekday s2 = 0;         // 仍然错误
Weekday s3(0);          // 仍然错误
Weekday s4 = {9};       // 仍然错误
```

如果 `Weekday` 有指定的底层类型，这同样适用：

```c++
// 带有指定底层类型的有作用域枚举：
enum class Weekday : char { mon, tue, wed, thu, fri, sat, sun };
Weekday s1{0};          // C++17 起正确（C++17 前错误）
Weekday s2 = 0;         // 仍然错误
Weekday s3(0);          // 仍然错误
Weekday s4 = {9};       // 仍然错误
```

对于*没有*指定底层类型的无作用域枚举（不带有 `class` 的 `enum`），你仍然不能将列表初始化用于整数值：

```c++
enum Flag { bit1=1, bit2=2, bit3=4 };
Flag f1{0};         // 仍然错误
```

也要注意列表初始化仍然不允许窄化，这意味着你不能传入浮点值：

```c++
enum MyInt : char { };
MyInt i5{42.2};     // 仍然错误
```

这一特性的动机是支持定义新整数类型的技巧，即只需定义一个映射到现有整数类型的枚举类型，就像这里 `MyInt` 那样。如果没有这一特性，就没有办法不使用转换而初始化新对象。

事实上，从 C++17 起，C++ 标准库也提供了 `std::byte`（见第 18 章），它直接使用了这一特性。