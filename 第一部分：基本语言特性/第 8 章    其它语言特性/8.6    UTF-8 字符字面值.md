### 8.6    UTF-8 字符字面值

自 C++11 起，C++ 支持表示 UTF-8 字符串字面值的前缀 `u8`。然而，该前缀不能用于字符字面值。C++17 修复了这个不同，因此你可以编写：

```c++
auto c = u8'6';    // 使用 UTF-8 编码的字符 6 的值
```

在 C++17 中，`u8'6'` 的类型是 `char`，这可能在 C++20 中被改为 `char8_t`，因此这里使用 `auto` 可能是合适的。

这样你就可以保证该字符的值是字符 `'6'` 在 UTF-8 中的值。你可以使用所有 7 位的 US-ASCII 字符，它们在 UTF-8 编码中有相同的值。也就是说，根据 7 位 US-ASCII（因此也根据 ISO Latin-1、ISO-8859-15 和基础 Windows 字符集），`u8'6'` 指定拥有字符 `'6'` 的正确值。[^3] 通常，你的源代码无论如何都会解释 US-ASCII/UTF-8 中的字符，这意味着这一前缀不是必要的。`c` 的值几乎总是 `54`（十六进制 `36`）。

[^3] ISO Latin-1 正式命名为 ISO-8859-1，而为了包含欧洲欧元符号 € 而引入的 ISO 字符集 ISO-8859-15 也叫做 ISO Latin-9（是的，这不是拼写错误）。

然而，在极少数情况下可能并非如此。例如，在（仍然）使用 EBCDIC 字符集的旧 IBM 主机上，字符 `'6'` 将拥有值 `246`（十六进制 `F6`）。因此，在使用 EBCDIC 字符集的程序中，上面字符 `c` 的值将是 246，而不是 54，所以在 UTF-8 编码的平台上运行该程序可能打印字符 `ö`，也就是在 ISO/IEC 8859-x 编码中（如果可用）值为 246 的字符。在像这样的情况下，这一前缀可能是必要的。

注意 `u8` 只能用于单个字符以及在 UTF-8 中具有单个字节（编码单元）的字符。下面这样的初始化：

```c++
char c = u8'ö';
```

是不允许的，因为在 UTF-8 中德语变音符号 `ö` 的值是两个字节的序列，即 `195` 和 `182`（十六进制 `C3 B6`）。

最后，字符和字符串字面值现在都接受以下前缀：

+ 用于单个字节 US-ASCII 和 UTF-8 编码的 `u8`
+ 用于双字节 UTF-16 编码的 `u`
+ 用于四字节 UTF-32 编码的 `U`
+ 用于未指定编码的宽字符（可能是二字节或四字节）的 `L`