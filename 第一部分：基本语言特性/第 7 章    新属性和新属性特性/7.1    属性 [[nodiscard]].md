## 第 7 章    新属性和新属性特性

C++11 起可以指定属性（启用或禁用警告的正式注解）。C++17 引入了新属性。此外，现在可以在更多的地方使用属性，并且更加方便。

### 7.1    属性 `[[nodiscard]]`

新属性 `[[nodiscard]]` 可以用于当函数的返回值不被使用时鼓励编译器发出警告（然而，发出警告不是要求的）。

`[[nodiscard]]` 通常应该用于在不使用返回值时提示不当行为。不当行为可能是：
+ **内存泄露**，例如未使用返回的分配的内存
+ **令人意外或不符合直觉的行为**，例如在不使用返回值时得到不同/不期望的行为
+ **不必要的开销**，例如如果不使用返回值，就会调用无操作的东西

下面是一些使用该属性很有用的例子：
+ 分配资源，且资源必须被其他函数调用释放的函数应该被标记为 `[[nodiscard]]`。一个典型是例子是分配内存的函数，例如 `malloc()` 或分配器的成员函数 `allocate()`。
  
  然而，注意有些函数*可能*返回一个值，表示不需要补偿调用。例如，程序员使用零字节大小来调用 C 函数 `realloc()` 以释放内存，因此不需要保存返回值以供后续调用 `free()`。出于这个原因，将 `realloc()` 标记为 `[[nodiscard]]` 可能会适得其反。
+ 不使用返回值时会非直观地改变函数行为的一个例子是 `std::async()`（C++11 引入）。`std::async()` 在后台异步启动一个功能，并返回一个句柄，能用于等待启动的功能结束（并访问返回值或异常）。然而，当不使用返回值时该调用就变成了同步调用，因为这会立刻调用未使用的返回值的析构函数，这将等待启动的功能结束。因此，不使用返回值与调用 `std::async()` 的目的相矛盾。当 `std::async()` 被标记为 `[[nodiscard]]` 时，编译器可以对这种情况发出警告。
+ 另一个例子是成员函数 `empty()`，它检查对象（容器或字符串）是否没有元素。程序员经常调用这个函数来“清空”容器（移除所有元素）：
  
  ```c++
  cont.empty();
  ```
  
  对 `empty()` 的这一不正确的使用经常可以被检测到，因为没有使用返回值。因此，相应地标记该成员函数：

  ```c++
  class MyContainer {
    ...
    public:
      [[nodiscard]] bool empty() const noexcept;
      ...
  };
  ```
  
  有助于检测到这样的逻辑错误。

如果出于某种原因，你不想使用标记为 `[[nodiscard]]` 的返回值，可以将返回值转换为 `void`：

```c++
(void)coll.empty();     // 禁用 [[nodiscard]] 警告
```

注意，如果函数被重写，不会继承函数声明中的属性：

```c++
struct B {
  [[nodiscard]] int* foo();
};

struct D : B {
  int* foo();
};

B b;
b.foo();        // 有警告
(void)b.foo();  // 没有警告

D d;
d.foo();        // 没有警告
```

因此，你需要再次使用 `[[nodiscard]]` 标记派生的成员函数（除非有理由认为在派生类中不使用返回值是有意义的）。

与平常一样，你可以将应用到函数的属性放置在所有声明说明符之前，或者函数名之后：

```c++
class C {
  ...
  [[nodiscard]] friend bool operator== (const C&, const C&);
  friend bool operator!= [[nodiscard]] (const C&, const C&);
};
```

将属性放在 `friend` 和 `bool` 之间或 `bool` 和 `operator==` 之间是不正确的。

尽管这一语言特性在 C++17 中引入，但它尚未用于标准库。在 C++17 中，应用这一特性的提案来得太晚了。因此，作为这个特性的关键动机之一，即将它添加到 `std::async()` 的声明中，还没有完成。然而，对于上面讨论的所有例子，相应的修复将在下一个 C++ 标准中到来（见 https://wg21.link/p0600r1 提案，在 C++20 中接受）。

然而，为了让你的代码更具可移植性，你应该使用 `[[nodiscard]]` 而不是不便移植的方法（例如 gcc 和 clang 的 `[[gnu::warn_unused_result]]` 或 Visual C++ 的 `_Check_return_`）来相应地标记函数。

在定义 `operator new()` 时（见 30.2.2 节），你应该将函数标记为 `[[nodiscard]]`，例如，在定义用于追踪 `new` 的所有调用的头文件时（见 30.4 节）。