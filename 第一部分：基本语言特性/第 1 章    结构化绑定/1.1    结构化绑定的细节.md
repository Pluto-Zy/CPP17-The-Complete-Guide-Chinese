## 第 1 章    结构化绑定

结构化绑定允许你用一个对象的元素或成员初始化多个实体。

例如，假设你已经定义了有两个不同成员的结构体：

```c++
struct MyStruct {
  int i = 0;
  std::string s;
};

MyStruct ms;
```

你可以使用下面的声明将这个结构体的成员直接绑定到新名字上：

```c++
auto [u, v] = ms;
```

这里，*名字* `u` 和 `v` 称为*结构化绑定*（structured binding）。在某种程度上，它们*分解*（decompose）了用于初始化的对象（有时它们也被称为*分解声明*（decomposition declaration））。

每一种初始化语法都支持结构化绑定：

```c++
auto [u2, v2] {ms};
auto [u3, v3] (ms);
```

对于返回结构体或数组的函数，结构化绑定特别有用。例如，考虑一个返回结构体的函数

```c++
MyStruct getStruct() {
  return MyStruct(42, "hello");
}
```

你可以将结果赋值给两个实体，直接为返回的数据成员提供局部名字：

```c++
auto[id,val] = getStruct();    // id 和 val 命名了返回的结构体中的 i 和 s
```

这里，`id` 和 `val` 是返回的结构体的成员 `i` 和 `s` 的名字。它们有对应的类型 `int` 和 `std::string`，也能作为两个不同的对象使用：

```c++
if (id > 30) {
  std::cout << val;
}
```

使用它的好处是能直接访问成员，并能提高代码的可读性：将值直接绑定到名字上，而这些名字具有语义含义，能表达它们的使用目的。[^1]

[^1]:感谢 Zachary Turner 指出这一点。

下面的代码展示了如何使用结构化绑定显著改进代码。在没有结构化绑定的情况下，要想迭代 `std::map<>` 的元素，你必须这样编程：

```c++
for (const auto& elem : mymap) {
  std::cout << elem.first << ": " << elem.second << '\n';
}
```

这些元素是键、值类型组成的 `std::pair`，而且由于 `std::pair` 的成员是 `first` 和 `second`，你必须使用这些名字来访问键和值。通过使用结构化绑定，代码会变得可读得多：

```c++
for (const auto& [key,val] : mymap) {
  std::cout << key << ": " << val << '\n';
}
```

我们可以使用带有清晰语义含义的名字直接使用每个元素的键、值成员。

### 1.1    结构化绑定的细节

为了理解结构化绑定，重要的是认识到其中涉及一个隐藏的匿名变量。结构化绑定引入的新名字指代这个匿名变量的成员 / 元素。

##### 绑定到匿名实体

初始化

```c++
auto [u,v] = ms;
```

的准确行为是，如同我们用 `ms` 初始化了一个新实体 *e*，并使结构化绑定 `u` 和 `v` 成为这个新对象的成员的别名，类似于定义

```c++
auto e = ms;
aliasname u = e.i;
aliasname v = e.s;
```

这表示 `u` 和 `v` 仅仅是 `ms` 的局部拷贝的成员的其它名字。然而，我们没有 *e* 的名字，这意味着我们不能通过名字直接访问这个被初始化的实体。注意 `u` 和 `v` 并不是对应于 `e.i` 和 `e.s` 的引用。`decltype(u)` 是成员 `i` 的类型，而 `decltype(v)` 是成员 `s` 的类型。

因此，

```c++
std::cout << u << ' ' << v << '\n';
```

将打印 `e.i` 和 `e.s` 的值，它们是 `ms.i` 和 `ms.s` 的拷贝。

*e* 的存活时间和建立其上的结构化绑定的存活时间一样长。因此，当结构化绑定离开作用域时，它会被销毁。

因此，除非使用引用，否则修改用于初始化的值对结构化绑定初始化的名字没有影响（反之亦然）：

```c++
MyStruct ms{42,"hello"};
auto [u,v] = ms;
ms.i = 77;
std::cout << u;       // 打印 42
u = 99;
std::cout << ms.i;    // 打印 77
```

`u` 和 `ms.i` 也具有不同的地址。

当对返回值使用结构化绑定时，也会应用相同的准则。类似于下面这样的初始化

```c++
auto [u,v] = getStruct();
```

表现得如同我们用 `getStruct()` 的返回值初始化了一个新实体 *e*，因此结构化绑定 `u` 和 `v` 成为了 *e* 的两个成员 / 元素的别名，类似于定义：

```c++
auto e = getStruct();
aliasname u = e.i;
aliasname v = e.s;
```

也就是说，结构化绑定绑定到了一个*新*实体上，这个新实体从返回值初始化，而不是直接绑定到了返回值上。

对于匿名实体 *e* 的类型，通常的布局保证也适用。结构化绑定和它们绑定的对应成员对齐。

##### 使用限定符

我们可以使用限定符，如 `const` 和引用。同样，这些限定符作为一个整体应用到匿名实体 *e* 上。通常情况下，这样的效果类似于将限定符直接应用到结构化绑定上，但要知道并不永远是这样（见下文）。

例如，我们可以声明对 `const` 引用的结构化绑定：

```c++
const auto& [u,v] = ms;       // 引用，因此 u/v 指代 ms.i/ms.s
```

这里，匿名实体声明为 `const` 引用，这表示 `u` 和 `v` 是成员 `i` 和 `s` 的名字，而这两个成员是初始化的对 `ms` 的 `const` 引用。因此，任何对 `ms` 的成员的修改都会影响 `u` 和 / 或 `v` 的值。

```c++
ms.i = 77;                    // 影响 u 的值
std::cout << u;               // 打印 77
```

如果声明为非 `const` 引用，你甚至可以修改用于初始化的对象 / 值的成员：

```c++
MyStruct ms{42,"hello"};
auto& [u,v] = ms;             // 被初始化的实体是 ms 的引用
ms.i = 77;                    // 影响 u 的值
std::cout << u;               // 打印 77
u = 99;                       // 修改 ms.i
std::cout << ms.i;            // 打印 99
```

如果用于初始化结构化绑定的引用是临时对象，那么像往常一样，临时对象的生存期会被扩展到结构化绑定的生存期：

```c++
MyStruct getStruct();
...
const auto& [a,b] = getStruct();
std::cout << "a: " << a << '\n';    // 正确
```

##### 限定符不一定会应用到结构化绑定

如前所述，限定符应用到新的匿名实体。它们不一定会应用到作为结构化绑定而引入的新名字上。事实上，经过

```c++
const auto& [u,v] = ms;   // 引用，因此 u/v 指代 ms.i/ms.s
```

`u` 和 `v` 都*不*被声明为引用。这仅仅指定了匿名实体 *e* 是引用。`u` 和 `v` 具有 `ms` 的成员的类型，然而，这两者在这里都成为了 `const`（就像你不能修改由常量引用传递的对象的成员）。对于我们一开始的声明，这表示 `decltype(u)` 是 `const int`，`decltype(v)` 是 `const std::string`。

这在指定对齐时也会产生不同：

```c++
alignas(16) auto [u,v] = ms;  // 对齐对象，而不是 v
```

这里，我们对齐了初始化的匿名实体，而不是结构化绑定 `u` 和 `v`。这意味着 `u` 作为首个成员被强制对齐到 16，而 `v` 没有。

出于相同的原因，即使使用了 `auto`，结构化绑定也不会*退化*（decay）[^2]。例如，如果我们有一个由原始数组组成的结构体：

[^2]:术语*退化*（decay）描述了当实参按值传递时发生的类型转换，即原始数组转换为指针，顶层限定符（如 `const` 和引用）被忽略。

```c++
struct S {
  const char x[6];
  const char y[3];
};
```

然后声明

```c++
S s1{};
auto [a, b] = s1; // a 和 b 获得了成员的精确类型
```

`a` 的类型仍然是 `const char[6]`。同样，`auto` 应用到匿名实体上，它作为一个整体不会退化。这不同于用 `auto` 初始化新对象，后者类型会退化：

```c++
auto a2 = a;      // a2 获得了 a 退化后的类型
```

##### 移动语义

按照刚刚介绍的规则，移动语义是支持的。在下面的声明中：

```c++
MyStruct ms = { 42, "Jim" };
auto&& [v,n] = std::move(ms);           // 实体是 ms 的右值引用
```

结构化绑定 `v` 和 `n` 指向匿名实体，该匿名实体是 `ms` 的右值引用，而 `ms` 仍然保存其值：

```c++
std::cout << "ms.s: " << ms.s << '\n';  // 打印 "Jim"
```

然而，你可以移动赋值 `n`，它指代 `ms.s`：

```c++
std::string s = std::move(n);           // 将 ms.s 移动到 s
std::cout << "ms.s: " << ms.s << '\n';  // 打印未指明的值
std::cout << "n:    " << n << '\n';     // 打印未指明的值
std::cout << "s:    " << s << '\n';     // 打印 "Jim"
```

与往常一样，被移动的源对象处于带有未指明的值的有效状态。因此，可以打印该值，但不能对打印的内容做出任何假设。[^3]

[^3]:对于字符串，被移动的源对象通常为空，但这*不*保证成立。

这与从 `ms` 的被移动的值初始化新实体略有不同：

```c++
MyStruct ms = { 42, "Jim" };
auto [v,n] = std::move(ms);             // 带有从 ms 移动的值的新实体
```

这里，被初始化的匿名实体是一个新对象，它用从 `ms` 移动的值初始化。因此，`ms` 已经失去其值：

```c++
std::cout << "ms.s: " << ms.s << '\n';  // 打印未指明的值
std::cout << "n:    " << n << '\n';     // 打印 "Jim"
```

你仍然能从 `n` 的值移动赋值，或者为它赋予新值，但这不影响 `ms.s`：

```c++
std::string s = std::move(n);           // 把 n 移动到 s
n = "Lara";
std::cout << "ms.s: " << ms.s << '\n';  // 打印未指明的值
std::cout << "n:    " << n << '\n';     // 打印 "Lara"
std::cout << "s:    " << s << '\n';     // 打印 "Jim"
```