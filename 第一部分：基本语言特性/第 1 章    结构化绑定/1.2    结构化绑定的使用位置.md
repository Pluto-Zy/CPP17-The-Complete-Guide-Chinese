### 1.2    结构化绑定的使用位置

原则上，结构化绑定可用于具有公有数据成员的结构体、原始 C 风格数组和 “类元组对象”：

+ 对于所有非静态数据成员都是公有的**结构体和类**，你可以将每个非静态数据成员都绑定到一个名字上。
+ 对于**原始数组**，你可以为数组的每个元素绑定一个名字。
+ 对于任意类型，你可以使用**元组式 API**将名字绑定到 API 定义为 “元素” 的任何实体上。对于类型 *type*，API 大致需要以下组件：
  + `std::tuple_size<type>::value` 必须返回元素数量。
  + `std::tuple_element<idx,type>::type` 必须返回第 *idx* 个元素的类型。
  + 全局或成员 `get<idx>()` 必须返回第 *idx* 个元素的值。
  
  标准库类型 `std::pair<>`、`std::tuple<>` 和 `std::array<>` 是提供了这些 API 的示例类型。

如果结构体或类提供了元组式 API，就使用该 API。

任何情况下，元素或数据成员的数量必须匹配结构化绑定的声明中名字的数量。你不能跳过名字，或重复使用某个名字。
然而，你可以使用非常简短的名字，例如 '`_`'（一些程序员喜欢使用，而其他人讨厌，但是该名字不允许在全局命名空间使用），不过这在相同作用域中只能使用一次。

```c++
auto [_,val1] = getStruct();  // 正确
auto [_,val2] = getStruct();  // 错误：名字 _ 已经被使用
```

不支持嵌套分解或非平整分解。

下一节将会详细讨论结构化绑定的所有这些用法。

#### 1.2.1    结构体和类

上文各节中的介绍性示例已经描述了带有公有成员的结构体和类的结构化绑定的一些简单用法。
其典型应用是直接使用在一个数据结构中返回的多个返回值（例如，结点柄的 `insert()`，见 26.1.2 节）。然而，需要注意一些边缘情况。

注意，继承的情况下只能使用有限的操作。所有非静态数据成员都必须是相同类定义的成员（因此，它们必须是当前类型或相同无歧义公有基类的直接成员）：

```c++
struct B {
  int a = 1;
  int b = 2;
};

struct D1 : B {
};
auto [x, y] = D1{};       // 正确

struct D2 : B {
  int c = 3;
};
auto [i, j, k] = D2{};    // 编译错误
```

注意，仅当公有成员的顺序保证固定时，才应该对其使用结构化绑定。否则，如果 `B` 中 `int a` 和 `int b` 的顺序发生改变，
`x` 和 `y` 立刻会从不同的值初始化。为了支持这一稳定性，C++17 为一些标准库结构定义了成员的顺序（例如，`insert_return_type`，见 26.1.2 节）。

不允许对联合使用结构化绑定。

#### 1.2.2    原始数组

下面的代码使用原始 C 风格数组的两个元素初始化 `x` 和 `y`：

```c++
int arr[] = { 47, 11 };
auto [x, y] = arr;    // x 和 y 是 arr 的副本的 int 元素
auto [z] = arr;       // 错误：元素数量不匹配
```

注意这是 C++ 中少有的几种按值复制原始数组的情况之一。

只有在数组仍然具有已知大小时，才能使用这一初始化。对于作为实参按值传递的数组，这是不能完成的，因为数组*退化*（decay）为了对应的指针类型。

注意 C++ 允许我们通过引用返回具有大小的数组，因此这一特性也适用于返回数组的函数，只要数组的大小是返回类型的一部分：

```c++
auto getArr() -> int(&)[2];   // getArr() 返回对原始 int 数组的引用
...
auto [x, y] = getArr();       // x 和 y 是返回的数组的副本的 int 元素
```

你也可以对 `std::array` 使用结构化绑定，它使用了元组式 API 实现，正如下一节描述的那样。

#### 1.2.3    `std::pair`、`std::tuple` 和 `std::array`

结构化绑定机制是可扩展的，这意味着你可以为任意类型添加对结构化绑定的支持。标准库将其用于 `std::pair<>`、`std::tuple<>` 和 `std::array<>`。

##### `std::array`

例如，下面的代码将 `a`、`b`、`c` 和 `d` 初始化为 `getArray()` 返回的 `std::array<>` 的副本中的四个元素的别名：

```c++
std::array<int, 4> getArray();
...
auto [a,b,c,d] = getArray();    // a, b, c, d 是返回值的副本中 4 个元素的别名
```

此处，`a`、`b`、`c` 和 `d` 是 `getArray()` 返回的 `std::array` 的元素的结构化绑定。

只要用于初始化的值不是返回值临时量，同时我们使用了非 `const` 引用，写访问就是支持的。例如：

```c++
std::array<int,4> stdarr { 1, 2, 3, 4 };
...
auto& [a,b,c,d] = stdarr;
a += 10;                  // 正确：修改了 stdarr[0]

const auto& [e,f,g,h] = stdarr;
e += 10;                  // 错误：对常量对象的引用

auto&& [i,j,k,l] = stdarr;
i += 10;                  // 正确：修改了 stdarr[0]

auto [m,n,o,p] = stdarr;
m += 10;                  // 正确：但是修改了 stdarr[0] 的拷贝
```

然而，和往常一样，我们不能从临时对象（纯右值）初始化非 `const` 引用：
```c++
auto& [a,b,c,d] = getArray();   // 错误
```

##### `std::tuple`

下面的代码将 `a`、`b` 和 `c` 初始化为 `getTuple()` 返回的 `std::tuple<>` 的副本中的三个元素的别名：

```c++
std::tuple<char,float,std::string> getTuple();
...
auto [a,b,c] = getTuple();      // a,b,c 拥有返回的元组中对应元素的类型和值
```

也就是说，`a` 得到类型 `char`，`b` 得到类型 `float`，`c` 得到类型 `std::string`。

##### `std::pair`

作为另一个例子，处理在关联/无序容器

```c++
std::map<std::string, int> coll;
```

上调用 `insert()` 的返回值的代码可以避免使用结果 `std::pair<>` 对象的一般的名字 `first` 和 `second`：

```c++
auto ret = coll.insert({"new",42});
if (!ret.second){
  // 如果插入失败，使用迭代器 ret.first 处理错误
  ...
}
```

而是将其绑定到能传达关于使用目的的语义含义的名字上：

```c++
auto [pos,ok] = coll.insert({"new",42});
if (!ok) {
  // 如果插入失败，使用迭代器 pos 处理错误
  ...
}
```

从而提高可读性。

注意在这种特殊情况下，C++17 提供了带初始化器的 `if`（见 2.1 节）以进一步提高可读性。

##### 为 `pair` 和 `tuple` 的结构化绑定赋予新值

声明结构化绑定后，你通常不能同时修改所有的绑定，因为结构化绑定只能一同声明，不能一同使用。
然而，如果要赋予的值可以赋予 `std::pair<>` 或 `std::tuple<>`，你就可以使用 `std::tie()`。

也就是说，你可以像下面这样实现：

```c++
std::tuple<char,float,std::string> getTuple();
...
auto [a,b,c] = getTuple();        // a,b,c 拥有返回的元组的对应类型和值
...
std::tie(a,b,c) = getTuple();     // a,b,c 得到了下一个返回的元组的值
```

特别地，这可以用于实现处理一对返回值的循环，例如在循环中使用搜索器（见 24.1.2 节）时：

```c++
std::boyer_moore_searcher bmsearch{sub.begin(), sub.end()};
for (auto [beg, end] = bmsearch(text.begin(), text.end());
     beg != text.end();
     std::tie(beg,end) = bmsearch(end, text.end())) {
  ...
}
```