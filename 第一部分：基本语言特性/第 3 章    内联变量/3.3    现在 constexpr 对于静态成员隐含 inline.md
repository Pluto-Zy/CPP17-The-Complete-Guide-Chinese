### 3.3    现在 `constexpr` 对于静态成员隐含 `inline`

对于静态数据成员，`constexpr` 现在隐含 `inline`，因此从 C++17 起，下面的声明*定义*了静态数据成员 `n`：

```c++
struct D {
  static constexpr int n = 5; // C++11/C++14：声明
                              // C++17 起：定义
};
```

也就是说，这等价于：

```c++
struct D {
  inline static constexpr int n = 5;
};
```

注意，在 C++17 前，你通常只能得到没有对应定义的声明。考虑下面的声明：

```c++
struct D {
  static constexpr int n = 5;
};
```

如果不需要 `D::n` 的定义，这就足够了，`D::n` 仅仅按值传递时就是这种情况：

```c++
std::cout << D::n;          // 正确（ostream::operator<<(int) 按值得到 D::n
```

如果 `D::n` 按引用传递给了非内联函数，且/或该调用没有被优化掉，这就是不合法的。例如：

```c++
int twice(const int& i);

std::cout << twice(D::n);   // 通常是错误
```

这段代码违反了*单一定义规则*（ODR）。当使用优化编译器构建时，它可能按照预期工作，或者由于缺少定义而给出链接错误。在没有任何优化的情况下构建时，由于缺少 `D::n` 的定义，这几乎肯定会被拒绝。由于缺少定义，创建指向静态成员的指针更可能导致链接错误（但在一些编译器模式下仍然可能工作）：

```c++
const int* p = &D::n;       // 通常是错误
```

因此，在 C++17 前，必须在一个且仅一个翻译单元中定义 `D::n`：

```c++
constexpr int D::n;         // C++11/C++14：定义
                            // C++17 起：多余的声明（被弃用）
```

现在，当使用 C++17 构建时，类内的声明本身是定义，因此上面的所有例子现在在没有前一个定义的情况下都是有效的。前一个定义仍然有效，但是变成了一个弃用的多余声明。